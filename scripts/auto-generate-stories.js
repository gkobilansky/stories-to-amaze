/**
 * Automated Story Generation Pipeline
 * Research products ‚Üí Generate stories ‚Üí Commit to GitHub
 */

import { researchProducts } from './research-products.js';
import { generateStory } from './generate-story.js';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Get real Amazon product URL (placeholder for now)
 * In production, this would use Amazon Associates SiteStripe or API
 */
function getAmazonProductURL(productName, asin) {
  // For now, return example URL
  // In production, you'd generate real amzn.to links with your tag
  const slug = productName.toLowerCase().replace(/[^a-z0-9]+/g, '');
  return `https://amzn.to/${slug}`;
}

/**
 * Convert research data to story input format
 */
function convertResearchToStoryInput(research) {
  const product = research.suggestedProduct || {};

  return {
    name: product.name || research.productType,
    description: product.description || research.problem,
    asin: product.asin || 'B0PENDING',
    price: product.estimatedPrice || research.priceRange?.split('-')[0]?.trim() || '$XX.XX',
    url: getAmazonProductURL(product.name || research.productType, product.asin),
    keywords: [research.primaryKeyword, ...research.relatedKeywords.slice(0, 2)],
    categories: [research.category]
  };
}

/**
 * Git commit and push story
 */
function commitAndPush(storyResult) {
  try {
    const cwd = path.join(__dirname, '..');

    // Add the new files
    execSync(`git add _posts/${path.basename(storyResult.markdownPath)}`, { cwd });
    execSync(`git add public/assets/blog/${storyResult.slug}/`, { cwd });

    // Commit
    const commitMessage = `Add story: ${storyResult.title}

Auto-generated by Stories to Amaze bot

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>`;

    execSync(`git commit -m "${commitMessage}"`, { cwd });

    // Push
    execSync('git push origin main', { cwd });

    console.log('‚úÖ Committed and pushed to GitHub');
    return true;
  } catch (error) {
    console.error('‚ùå Git error:', error.message);
    return false;
  }
}

/**
 * Main automation pipeline
 */
async function autoGenerateStories(options = {}) {
  const {
    category = 'pets',
    numResearch = 3,
    numStories = 2,
    autoPush = false
  } = options;

  console.log('ü§ñ Starting automated story generation pipeline...\n');
  console.log(`üìä Config:`);
  console.log(`  Category: ${category}`);
  console.log(`  Research: ${numResearch} products`);
  console.log(`  Generate: ${numStories} stories`);
  console.log(`  Auto-push: ${autoPush ? 'Yes' : 'No'}\n`);

  // Step 1: Research products
  console.log('üîç STEP 1: Researching products...\n');
  const { reports } = await researchProducts(category, numResearch);

  // Step 2: Filter ready products
  const readyProducts = reports
    .filter(r => r.readyForStory)
    .sort((a, b) => b.score - a.score);

  if (readyProducts.length === 0) {
    console.error('‚ùå No products ready for stories. Try different category or more research.');
    return;
  }

  console.log(`\n‚úÖ Found ${readyProducts.length} products ready for stories\n`);

  // Step 3: Generate stories
  const storiesToGenerate = Math.min(numStories, readyProducts.length);
  const results = [];

  console.log(`üìù STEP 2: Generating ${storiesToGenerate} stories...\n`);

  for (let i = 0; i < storiesToGenerate; i++) {
    const research = readyProducts[i];
    const productInput = convertResearchToStoryInput(research);

    console.log(`\n--- Story ${i + 1}/${storiesToGenerate} ---`);
    console.log(`Product: ${productInput.name}`);
    console.log(`Keywords: ${productInput.keywords.join(', ')}\n`);

    try {
      const storyResult = await generateStory(productInput);
      results.push({ success: true, research, storyResult });

      console.log(`‚úÖ Story generated: "${storyResult.title}"\n`);

      // Optional: Commit and push immediately
      if (autoPush) {
        console.log('üì§ Pushing to GitHub...');
        commitAndPush(storyResult);
      }

      // Rate limiting (be nice to Google AI)
      if (i < storiesToGenerate - 1) {
        console.log('‚è≥ Waiting 5 seconds before next story...\n');
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    } catch (error) {
      console.error(`‚ùå Failed to generate story: ${error.message}`);
      results.push({ success: false, research, error: error.message });
    }
  }

  // Step 4: Summary
  console.log('\n\nüìä PIPELINE COMPLETE!\n');
  console.log('‚ïê'.repeat(50));

  const successful = results.filter(r => r.success);
  console.log(`\n‚úÖ Successful: ${successful.length}/${results.length}`);

  if (successful.length > 0) {
    console.log('\nGenerated stories:');
    successful.forEach((result, i) => {
      console.log(`  ${i + 1}. "${result.storyResult.title}"`);
      console.log(`     File: _posts/${path.basename(result.storyResult.markdownPath)}`);
    });
  }

  const failed = results.filter(r => !r.success);
  if (failed.length > 0) {
    console.log(`\n‚ùå Failed: ${failed.length}`);
    failed.forEach((result, i) => {
      console.log(`  ${i + 1}. ${result.research.productType}: ${result.error}`);
    });
  }

  if (!autoPush && successful.length > 0) {
    console.log('\nüí° To publish these stories, run:');
    console.log('   git add _posts/ public/assets/blog/');
    console.log('   git commit -m "Add new stories"');
    console.log('   git push origin main');
  }

  return results;
}

// Export for use in other scripts
export { autoGenerateStories };

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);

  const options = {
    category: args[0] || 'pets',
    numResearch: parseInt(args[1]) || 3,
    numStories: parseInt(args[2]) || 2,
    autoPush: args.includes('--push')
  };

  autoGenerateStories(options)
    .then(results => {
      const successful = results.filter(r => r.success).length;
      process.exit(successful > 0 ? 0 : 1);
    })
    .catch(error => {
      console.error('\n‚ùå Pipeline error:', error);
      process.exit(1);
    });
}
